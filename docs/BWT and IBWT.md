# BWT及其逆变换的算法分析

---

[BWT算法](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform)于1994年由Michael Burrows和David Wheeler提出，它的作用主要是改善序列的局部相关性，以便使用MTF算法降低其信息熵，从而获得更高的压缩比

#### 原理
可以在wiki上看到，BWT的原理实现中，对一个长度为n的序列，需要一个大小为(n+1)^2^的矩阵进行变换，于是在序列增长的情况下，占用的内存急剧增加，在n=10^6^B时，矩阵占用的内存大于1TB，这是无法实现的；同时，对于这么大的矩阵进行遍历和排序的时间复杂度也是不可接受的，因此对于该算法的设计，应当**着眼于时间复杂度和空间复杂度的优化**

首先要明确：
1. BWT的结果是唯一的
2. 循环移位的方式（左移或者右移）不影响最后结果
3. 相近的序列进行BWT的结果也许差别很大（插入结束符与否的情况）
4. 时间复杂度不可能无线优化，目前最好情况的估计就是O($nlogn$)到O($n^2logn$)

#### 方法
> 一种基于后缀排序快速实现Burrows-Wheeler变换的方法

基于后缀排序的BWT实现，基本上解决了空间复杂度的问题
对于一个长度为$n$的数组，实现基于后缀排序的BWT的过程应该如下：
+ 插入标志元素，这个标志元素的字典序应该大于数组中的所有元素（即值最小） 
+ 取后缀数组，并对取到的后缀数组进行字典序排序
+ 排序依次取每个后缀数组前的一个元素（对于长度为$n+1$的后缀数组，就取标志元素）
+ 将上一步中取到的元素依次存储，即是所求的`Burrows-Wheeler`转换的结果，标志元素的位置（从零开始数）就是所求的索引值  

在取后缀数组的时候，不必将后缀数组的元素存储到别处，只需取原数组的指针偏移，使用结构体记录下后缀数组相对原数组的位置和长度即可
```c++
/* Logic Suffix Array Definition */
typedef struct 
{
	int16_t* nnstr;			/* !< the cache pointer */
	uint32_t position;		/* !< the position in origin Array */
	uint32_t length;		/* !< the length of nnstr */
}SuffixArray_TypeDef;
```
假设在`32-bit`系统上，每个结构体占用的内存是12字节，共取出n+1个后缀数组，则占用的总内存应该是12(n+1)字节，相对原理算法的(n+1)^2字节来说，极大的降低了内存的占用

对后缀数组的字典序排序，目前使用的是冒泡排序（bubble sort），该算法的时间复杂度在最好情况下O(n\^2)（原数组已经按正序排序好），最坏情况下为O(n\^3)（原数组已经按倒序排序好），这样整个BWT算法的时间复杂度在O(n\^2)到O(n^3)之间，且实际上取不到极限情况

~~若将这部分更换为快排序（quick sort），算法的时间复杂度最好情况下应该是O(nlogn)，最坏情况下应该是O(n^2^logn)，最好与最坏情况同上，也取不到极限情况~~

此部分已经更换为归并排序（merge sort），算法时间复杂度同快排序，但是应当注意**函数调用栈（Call Stack）是否会越界**

综上，BWT的算法的时间复杂度和空间复杂度的优化可以告一段落，应该考虑具体的工程实现了

==即日起废弃基于添加唯一后缀字符的BWT算法，仅进行基于next值的新方法开发与总结，bwt.cpp冻结于2019.02.27==

#### 方法再思考
在上述方法中，考虑到了带有后缀结束符的情况，但是，也可以仅凭原序列进行后缀排序，以获得更好的空间复杂度，具体见`bwt2.cpp`

通过观察，BWT变换的索引值在轮转矩阵中表现为原序列的行数，在后缀数组中则相应的表现为排序后完整序列所在的行数，因此只需在排序前，标记完整序列并在排序后遍历得到完整序列所在的行号即可 

这种基于next值的方法运算量和存储需求明显低于添加唯一后缀字符的方法，而且便于解码获得原序列

#### BWT解码的思考
原理实现见[wiki](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform)，然而实际上，该方法并不适用于没有内建矩阵类型的c++，退一步说，即使c++内建矩阵类型也不能用，否则又要回退到BWT空间复杂度的难点之中了

但是BWT变换之后得到的序列总是满足这样几条性质：

1. BWT结果即BWT矩阵最后一列（L列），对该列进行字典序排序后即为BWT矩阵的第一列（F列）
2. BWT矩阵的第一列和最后一列中，同一种元素的相对位置不变，即F列中第一个出现的‘A'，一定对应L列第一个出现的'A'
3. 同一行中，F列的元素是L列元素的下一个元素  

通过以上三条性质，就可以逆序写出原序列了，当然在编程实现的时候，可以一次写出正确的原序列

~~经过验证，BWT解码算法的时间复杂度应该是O(n^2)，空间复杂度为3n，符合bzip2的“压缩占用内存是解压的三到七倍”的说法~~

#### 程序中的特殊实现
1. 匿名空间  

	实现代码如下例

	```c++
	/* Non-public Namespace */
	/* source file: bwt.cpp */
	namespace 
	{
		/* Logic Suffix Array Definition */
		typedef struct 
		{
			int16_t* nnstr;			/* !< the cache pointer */
			uint32_t position;		/* !< the position in origin Array */
			uint32_t length;		/* !< the length of nnstr */
		}SuffixArray_TypeDef;
	}
	```
	这里使用了c++中一种特殊的语法：匿名空间（anonymous namespace），它的用法相当于C语言中的`static`关键字，但是更强大

	`static`关键字的作用：
	- 修饰变量，使得变量作为静态变量，且对其他编译单元不可见
	- 修饰函数，使得函数对其他编译单元不可见，只能在本单元内访问

	而匿名空间的作用除了以上所说，它甚至还支持对类型的隐藏，使之对其他的编译单元不可见，如上代码中，便隐藏了`SuffixArray_TypeDef`类型，而访问这个类型时，有两种写法（以定义某个数据变量为例）

	```c++
	// SuffixArray 1
	::SuffixArray_TypeDef suf{nullptr, 0, 0};

	// SuffixArray 2
	SuffixArray_TypeDef suf{nullptr, 0, 0};
	```

	匿名空间的使用需要注意：
	+ 不宜在匿名空间中建立过于复杂的函数，只适宜于简单的helper函数
	+ 某些命令行式调试工具可能无法命中匿名空间中的断点
	+ 不要和`static`混用，否则可能会有无法预料的问题，甚至不建议在c++中使用该关键字

2. 模板元编程（Template Meta-Programming）

	接下来的所有实现均在`pbwt.h`，该头文件只允许被`bwt2.cpp`包含，重新定义了`class suffixArray`并实现了归并排序

	考虑到归并排序可能有其他的用处，因此使用模板实现，函数的原型如下

	```c++
	template <typename T>
	void __pbwt_merge_sort(T *arr, uint32_t left, uint32_t right);
	```

	其中`T`为该函数可以接受的类型，在函数实例化的时候由编译器确定，如果函数接受的不是基本类型，则需要重载操作符`=`和`>`，否则该函数无法执行

3. 操作符重载（Operator Reload）
	--to be continued...

#### Update
+ 2019-02-05
初步实现基于插入唯一结束字符的BWT算法  
+ 2019-02-19 
实现基于next值的BWT算法  
废弃基于唯一结束符的BWT算法  
+ 2019-02-27
实现基于next值的Inverse-BWT算法  
+ 2019-03-02
重构BWT算法，将排序方法由冒泡排序更换为归并排序，时间复杂度下降至O(n^2logn)  

---
`created by vscode, wrote by markdown(MPE), 2019-02-05, completed in 2019-02-27`